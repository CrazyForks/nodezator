<htsl>

<head>
  <title>Nodezator Manual | Other objects</title>
</head>

<body>

<p><a href="index.htsl">Table of contents</a> &gt; Other objects</p>

<h1>Other objects</h1>

<p>Besides the user-define nodes, Nodezator provides other objects to help make your node layout more versatile. Here we'll present each of them.</p>


<h2 id="text-blocks">Text blocks</h2>

<p>Text blocks represent comments within the node layout. To create one, just right-click an empty space on the canvas and click the <b>New text block</b> command on the popup menu that appears.</p>

<p>To edit the text, just click the text block and press <b>&lt;Ctrl+T&gt;</b>. The text blocks automatically adjust their sizes to fit the typed text, including new lines. Also, if you type "todo" words like TODO, XXX and FIXME inside the text block they are automatically highlighted. Here are some examples of text blocks in the image below:</p>

<img src="images/ch-other-objects_img00.png" alt="Text blocks" />


<h2 id="app-defined-nodes">App-defined nodes</h2>

<p>Nodezator has a number of app-defined nodes, that is, nodes the user doesn't need to define, which come by default with Nodezator.</p>

<p>In the next few sections we'll be presenting each of these nodes.</p>


<h2 id="operation-nodes">Operation nodes</h2>

<p><i>Operation nodes</i> or <i>operator nodes</i> are nodes like any other, but these app-defined nodes represent the usage of operators within Python, like <b>+</b>, <b>*</b>, etc. Remember that Python has operator overloading, which means operators can have user-defined meanings, depending on the objects in the operation. This makes these nodes even more powerful.</p>

<p>Their appearance is a bit different of other nodes, since they have no widgets nor a header, just the operation they represent written in their bodies with a large size, with the operator character(s) highlighted in red by default.</p>

<p>A tiny number at the topleft corner of each node represent their unique id. Here are some examples of operation nodes:</p>

<img src="images/ch-other-objects_img01.png" alt="Operation nodes" />

<p>To instantiate them, just right-click an empty space on the canvas and click one of the commands inside the <b>Common operations</b> submenu within the popup menu that appears. These commands are labeled according to the operation they represent, like <b>a + b</b>, <b>a * b</b>, etc.</p>

<h2 id="builtin-nodes">Built-in nodes</h2>

<p>They are just app-defined nodes which represent Python built-in functions/classes, like <i>print</i>, <i>sum</i>, etc. They look just like user-defined nodes, some even have widgets and all, but their header has a distinct color to tell them apart from user-defined nodes (by default this color is black). Here are some examples of built-in nodes:</p>

<img src="images/ch-other-objects_img02.png" alt="Built-in nodes" />

<p>To instantiate them, just right-click an empty space on the canvas and click one of the commands inside the <b>Built-in picks</b> submenu (and further separated according to their first letter) within the popup menu that appears.</p>

<h2 id="standard-library-nodes">Standard library nodes</h2>

<p>They are just app-defined nodes which represent callables from the Python standard library, like <i>itertools.chain</i>, <i>pprint.format</i>, etc. Just like built-in nodes, they also look like user-defined nodes and some have widgets and all. Their header also has a distinct color to tell them apart from user-defined nodes (by default this color is black, like the built-in nodes). Here are some examples of standard library nodes:</p>

<img src="images/ch-other-objects_img03.png" alt="Standard library node" />

<p>To instantiate them, just right-click an empty space on the canvas and click one of the commands inside the <b>Standard lib picks</b> submenu (and further separated by the standard library module to which the callable belongs) within the popup menu that appears.</p>


<h2 id="snippet-nodes">Snippet nodes</h2>

<p>App-defined nodes which represent useful Python snippets like "with blocks" for loading or saving files. They also look like user-defined nodes, widgets and all, and their header also have a distinct color (by default this color is black, like built-in and standard library nodes). Here are some examples of snippet nodes:</p>

<img src="images/ch-other-objects_img04.png" alt="Snippet node" />

<p>To instantiate them, just right-click an empty space on the canvas and click one of the commands inside the <b>Useful encapsulations</b> submenu within the popup menu that appears.</p>


<h2 id="data-nodes">Data nodes</h2>

<p>App-defined nodes whose only purpose is to provide data for other node(s). Data nodes represent variables within the node layout. Here are some examples of data nodes:</p>

<img src="images/ch-other-objects_img05.png" alt="Data node" />

<p>To instantiate them, just right-click an empty space on the canvas and click one of the commands inside the <b>New data node</b> submenu within the popup menu that appears to pick the kind of widget/data to be held by the node, including an option that presents a more complex form to specify the widget more precisely.</p>

<p>The default title on the data node can be changed, but it doesn't accept spaces or punctuation other than the underscore ("_"). This is so because the title of the data node is used as part of the variable name when the layout is exported as a Python script. The id of the node is used as part of the variable name as well, that is, the number to the left of the title that is assigned automatically by Nodezator.</p>


<h2 id="redirect-nodes">Redirect nodes</h2>

<p>App-defined nodes whose only purpose is to connect the output of a node with the input of other node(s). They are useful for helping organize the node layout. Here's a redirect node being used to connect data between two nodes.</p>

<img src="images/ch-other-objects_img06.png" alt="Redirect node" />

<p>To instantiate them, just right-click an empty space on the canvas and click the command <b>New redirect node</b> in the popup menu that appears.</p>

<h2 id="relationship-data-redirect-nodes">Relationship between data nodes and redirect nodes</h2>

<p>If you connect data to the input socket of a data node the data node changes its meaning (it doesn't represents a variable anymore) and becomes a redirect node. In such case, the node serves only to redirect the received input and it is as though the widget doesn't exist (the widget is hidden). If you sever the connection to the input socket, the node becomes a data node again and the widget reappears (unless there was no widget to begin with, in which case a button shaped like a plus sign "<b>+</b>" appears, which you can use to add a widget to the node).</p>

<p>If you delete the widget of a data node by clicking the small "x" icon to the right of the widget, it will be useless until you add a widget again or turns it into a redirect node by connection data to its input socket.</p>


<h2 id="callable-mode-app-defined-nodes">Callable mode in app-defined nodes</h2>

<p>As explained before, <a href="ch-defining-your-first-node.htsl#expanded-collapsed-callable-modes">user-defined nodes have 03 different modes</a>, that is, <b>expanded signature</b>, <b>collapsed signature</b> and <b>callable</b> modes. Just like user-defined nodes, app-defined nodes also have such modes. The only expection are operation nodes, which don't have a collapsed mode, because they are too tiny already.</p>

<p>The callable mode in particular can be used to achieve complex tasks with fewer nodes. In other words, they can simplify your graph a lot while still providing you power and versatility. In this section we'll just present a tiny example so you can see this in practice. Look at the graph in the image below, where multiple <b>a+b</b> operation nodes are used to add values together:</p>

<img src="images/ch-other-objects_img07.png" alt="Graph representing several additions by chained '+' operation nodes" />

<p>For now the graph is relatively small, but every time you need to add another value, you have to duplicate the operation node and so the graph will gradually become larger and larger.</p>

<p>If you use the <b>a+b</b> node in callable mode, though (by right-clicking it and, inside the <b>Change mode to</b> submenu, picking <b>callable</b>), you would only need a single one. Then you can use it in conjuntion with a <a href="https://docs.python.org/3/library/functools.html#functools.reduce">functools.reduce()</a> standard library node and a <b>tuple_from_args</b> snippet node to add as many values as you want without having to create several instances of the operator node. The tuple_from_args node is used to gather all values to be added into a single collection (in this case a tuple). Then we pass a reference to the a+b operation as the first argument of functools.reduce() and the collections as the second argument. Here's an alternative version of the graph in the previous image, but using the a+b node in callable mode with the other nodes we just described:</p>

<img src="images/ch-other-objects_img08.png" alt="Graph representing several additions by using a single '+' operation node in callable mode" />

<p>In other words, with just these 03 nodes (a+b, tuple_from_args and functools.reduce()) we can add as many values as we want! In the first version of this graph, if we wanted to add 10 more values, we would need at least 20 more nodes (one node with each new value and another a+b node). In this new version, we'd just need 10 more nodes, which would be the values we'd add to the tuple_from_args node.</p>

<p>You can use this to repeate many different kinds of operations at once. For instance, instead of a+b, you could have used an a*b operation node so all the values would be multiplied.</p>

<p>This is just a tiny example of how the callable mode can be used to achieve complex tasks with a very simple graph.</p>


<p><a href="ch-preview-widgets.htsl">Previous chapter</a> |  <a href="index.htsl">Table of contents</a> | <a href="ch-distributing-nodes.htsl">Next chapter</a></p>

</body>

</htsl>
