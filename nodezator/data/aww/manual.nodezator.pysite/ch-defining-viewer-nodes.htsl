<htsl>

<head>
  <title>Nodezator Manual | Defining viewer nodes</title>
</head>

<body>

<p><a href="index.htsl">Table of contents</a> &gt; Defining viewer nodes</p>

<h1>Defining viewer nodes</h1>

<p>Of course, we could just print the output of our get_circle node from the previous chapter using the print() node. However, since we may find ourselves working with more complex data as we further develop our nodes and node layouts, being able to define our own viewer nodes will be useful.</p>

<p>Since version 1.4.0, viewer nodes in Nodezator became even more versatile. They now vary greatly in what they can provide as visualizations. It all depends on what you want to provide as visualization features for your viewer nodes. You can make very simple viewer nodes that just provide an image to be displayed beside your node in the graph or you can make viewer nodes that have their own application loop where complex visualizations and even additional controls are presented.</p>

<p>In this chapter, we'll present the simplest way to define viewer nodes. Your viewer node will be able to display an image in the graph itself and also in a dedicated viewer provided by Nodezator by simply returning such images as pygame.Surface objects from your node.</p>

<p>The ability to define viewer nodes featuring custom application loops with complex visualizations and even additional controls will be presented in future chapters far ahead in the manual, since they are more advanced.</p>

<p>Also, do not let the terms <b>simple</b> and <b>complex/advanced</b> give you the false impression that simpler viewer nodes are less powerful though. More advanced viewer node features exist to tackle specific needs that the simpler viewer nodes can't, but it doesn't make them more powerful or desirable. As we'll explain in future chapters handling the more advanced features, more complex viewer nodes only exist because of extra requirements of the data to be visualized.</p>

<p>Without further ado, let's define our simple yet powerful viewer node.</p>

<p>Begin by creating another folder inside points2d called <i>viewer</i> wherein we'll store a node responsible for viewing points. This is just another <b>category folder</b>, just like point_creation.</p>


<h2 id="returning-visual-beside-node">Returning a visual to be displayed beside your node</h2>

<p>The simplest way by which you can display visuals with your viewer node, is by returning a pygame surface from it that can be displayed in the graph itself beside the node, when the node is executed.</p>

<p>Before we delve into the full implementation of our viewer node, I present below a first draft of the function that will generate our viewer node.</p>

<python>
### viewer node first draft

### function definition

def view_drawn_points(points):
    ...

### function aliasing as 'main_callable'
main_callable = view_drawn_points
</python>

<p>As you can see, our viewer node is just a regular node like any other. It has a single parameter where we'll receive the given points that we want to visualize. It is also aliased as <i>main_callable</i> like any other node, so that Nodezator can fetch it and turn it into a node.</p>

<p>Now, all you need is a way to inform Nodezator of two things:</p>

<ul>
    <li>that your node will provide a surface to display in the graph; and</li>
    <li>where to pick the surface from your node's output</li>
</ul>

<p>To do that, all you need is to add a small function in your script called (or aliased as) <i>get_sideviz_from_output</i>. The function must receive a single argument, which is the output of the node, and return the surface it gets from it.</p>

<p>Since in our case, the surface is the node's output itself, that function just needs to return the argument received. Here's the script defining our viewer node:</p>
 
<python uselineno="true">
### third-party imports

from pygame import Rect, Surface

from pygame.draw import rect as draw_rect


def view_drawn_points(points):

    ### ensure our points are stored in a list
    points = list(points)

    ### define size of the bounding box of our points, that is, the size
    ### of the rectangle that contains all of them

    left = min(p[0] for p in points)
    right = max(p[0] for p in points)

    top = min(p[1] for p in points)
    bottom = max(p[1] for p in points)

    width = right - left
    height = bottom - top

    ### let's increment the size by 20 pixels in each dimension, so
    ### we have a bit of padding around the points that will be
    ### drawn in the surface

    width += 10
    height += 10

    ### now create a surface with such dimensions, filled with white,
    ### and also store coordinates representing the center of such
    ### surface

    surface = Surface((width, height)).convert()
    surface.fill('white')

    centerx, centery = surface.get_rect().center

    ### now draw the points one by one in the surface with the color
    ### blue, as small rects;
    ###
    ### note that before drawing, we offset the points by the distance
    ### to the center of the surface, so they are drawn in the surface
    ### as though the center of the surface was the origin of the 2D
    ### space

    small_rect = Rect(0, 0, 3, 3)

    for x, y in points:

        offset_point = x + centerx, y + centery

        small_rect.center = offset_point

        draw_rect(surface, 'blue', small_rect)


    ### finally, return the surface
    return surface


### alias the function defining the node as main_callable
main_callable = view_drawn_points

### define a get_sideviz_from_output function that just returns
### the data received (the name of the parameter isn't important)
get_sideviz_from_output = lambda node_output: node_output
</python>

<p>And now your viewer node will look like this when instantiated:</p>

<img src="images/ch-defining-viewer-nodes_img00.png" alt="view_drawn_points node when instantiated" />

<p>And like this after we execute it:</p>

<img src="images/ch-defining-viewer-nodes_img01.png" alt="view_drawn_points node after execution" />

<p>The visualization that appears beside the viewer node is called an <b>in-graph visual</b> or <b>in-graph surface</b>, or even <b>in-graph visual data</b>. Note that the in-graph visual has a button on top that says <b>Reload</b>. As expected, clicking that button causes the node to execute so the visualization is updated. Of course, in order for the node to be executed, the upstream nodes from it are executed as well, so it receives up-to-date inputs.</p>

<p>That's it! At this point, you should be able to test the node pack you created with your get_circle and view_drawn_points nodes.</p>


<h2 id="returning-larger-visual">Returning a larger visual to be displayed in a Nodezator viewer</h2>

<p>In the previous subsection, you might have asked yourself why we needed to tell Nodezator where specifically to grab the in-graph surface from the node's output. That is, if there's only one surface, why provide a function to grab it instead of just using a flag that says the output itself is the surface we want? The answer is that the output of the node might contain yet another surface of interest.</p>

<p>As with any application, the more graphics you display on the screen, the more the performance of the app is impacted. For most cases, the method we described before to provide a surface to be displayed in-graph is more than enough and will result in no harm to the performance, even if you use many viewer nodes like that.</p>

<p>However, what if you wanted to use Nodezator to edit 4K or 8K images, or any kind of data whose visualization resulted in a excessively large surface? In such cases, rather than showing the full visualization in the graph, you may instead want to show a smaller preview, but still provide the full visualization (the larger surface) so that Nodezator can show it in a dedicated viewer that is invoked when the user clicks the in-graph surface.</p>

<p>This way, you don't need to worry about the size of the surfaces your viewer nodes return. When you create a surface within your node, you just need to ensure it fits a maximum size arbitrarily defined by you and, if the surface is larger than that size, you create a downsized copy of it (using the <a href="https://pyga.me/docs/ref/transform.html#pygame.transform.smoothscale">smoothscale()</a> or <a href="https://pyga.me/docs/ref/transform.html#pygame.transform.scale">scale()</a> function from pygame-ce's <i>pygame.transform</i> module). If the surface is smaller than that, you can use it as-is for the in-graph visualization.</p>

<p>To tell Nodezator that you are providing a surface that is meant to appear in a dedicated viewer instead of in the graph itself, you just need to create another function called (or aliased as) <i>get_loopviz_from_output</i>, in addition to your existing <i>get_sideviz_from_output</i> function. This <i>get_loopviz_from_output</i> also receives a single input, which is the output of the node and must return the surface that Nodezator will display whenever the user clicks the in-graph visual.</p>

<p>Providing this new <i>get_loopviz_from_output</i> callable requires that a <i>get_sideviz_from_output</i> callable exist as well, otherwise Nodezator won't acknowledge the existence of your node as a viewer node. In other words, providing a full visual requires that you also provide a preview visual.</p>

<p>This time, to demonstrate this, we'll define a completely different viewer node that receives an image object from the <a href="https://pillow.readthedocs.io/en/stable/">Pillow</a> library in order to visualize it. We'll call it view_image node. Here's the script defining the node:</p>


<python uselineno="true">


### third-party imports

## pygame

from pygame import Surface

from pygame.math import Vector2

from pygame.image import fromstring as image_from_string

from pygame.transform import smoothscale as smoothscale_surface


## Pillow
from PIL.Image import Image



### 2D vector representing origin
ORIGIN = Vector2()


### main callable

def view_image(

    image: Image,
    max_preview_size: 'natural_number' = 600,

) -&gt; [

    {'name': 'full_surface', 'type': Surface},
    {'name': 'preview_surface', 'type': Surface},

]:
    """Return dict with pygame-ce surfaces representing given image.

    Parameters
    ==========
    image
        Pillow image from which to create surfaces.
    max_preview_size
        maximum diagonal length of the preview surface. Must be &gt;= 0.
        If 0, just use the full surface.
    """

    ### obtain surface from pillow image

    mode = image.mode
    size = image.size
    data = image.tobytes()

    full_surface = image_from_string(data, size, mode)

    ### if the max preview size is 0, it means the preview doesn't need
    ### to be below a specific size, so we can use the full surface
    ### as the preview

    if not max_preview_size:

        preview_surface = full_surface

        return {
            'full_surface': full_surface,
            'preview_surface': preview_surface,
        }

    ### otherwise, we must create a preview surface within the allowed size,
    ### if the full surface surpasses such allowed size

    ## obtain the bottom right coordinate of the image, which is
    ## equivalent to its size
    bottomright = full_surface.get_size()

    ## use the bottom right to calculate its diagonal length
    diagonal_length = ORIGIN.distance_to(bottomright)

    ## if the diagonal length of the full surface is higher than the
    ## maximum allowed size, we create a new smaller surface within
    ## the allowed size to use as the preview

    if diagonal_length &gt; max_preview_size:

        size_proportion = max_preview_size / diagonal_length
        new_size = ORIGIN.lerp(bottomright, size_proportion)

        preview_surface = smoothscale_surface(full_surface, new_size)


    ### otherwise, just alias the full surface as the preview surface;
    ###
    ### that is, since the full surface didn't need to be downscaled,
    ### it means it is small enough to be used as an in-graph visual
    ### already

    else:
        preview_surface = full_surface

    ### finally, return a dict containing both surfaces;
    ###
    ### you can return the surfaces in any way you want, inside a list,
    ### inside a tuple or a dictionary, etc.; the format isn't important,
    ### because we specify functions further below in the script to fetch
    ### them for us regardless of where we placed them anyway

    return {
        'full_surface': full_surface,
        'preview_surface': preview_surface,
    }


### alias the function defining the node as main_callable
main_callable = view_image

### define a get_sideviz_from_output function;
###
### since we store our in-graph visual in the 'preview_surface' key
### of the node's output (the dict returned), this function just
### returns the value in that key
get_sideviz_from_output = lambda node_output: node_output['preview_surface']

### define a get_loopviz_from_output function;
###
### again, because our full surface (the loop data) is stored as
### the 'full_surface' key of the node's output, this function just 
### returns the value in such key
get_loopviz_from_output = lambda node_output: node_output['full_surface']
</python>

<p>And now this viewer node will look like this when instantiated:</p>

<img src="images/ch-defining-viewer-nodes_img02.png" alt="view_image node when instantiated" />

<p>And like this after we execute it:</p>

<img src="images/ch-defining-viewer-nodes_img03.png" alt="view_image node after execution" />

<p>Clicking the in-graph surface showing the strawberry basket in the image above will cause the full surface to be shown using a special surface viewer provided by Nodezator. This viewer has other features as well, like allowing the user to scroll the image using the keyboard or to drag the image around using the mouse.</p>

<p>Just like the in-graph surface is also called in-graph visual, we also call this full surface, <b>full visual</b>. It is also called <b>loop data</b>, since it is data shown in a visualization loop. It just happens that such data is a surface. In the future though, this loop data may be of other types, like a string to be visualized as text, in case you are working with textual data. For instance, natural language, code or text-based data formats like python literals or JSON.</p>

<p>Note that, in addition to the <b>Reload</b> button, the viewer node now also has a check button labeled <b>Loop on execution</b>. If the check button is marked, whenever the node is executed the app will also enter the loop of the surface viewer. You'll probably leave this button unmarked most of the time, since the in-graph visual will likely be enough.</p>

<p>However, whenever you are fine-tuning the inputs in your graph to obtain a more accurate visualization, you'll probably leave the button marked so that you can inspect the full visual right away, instead of having to click the in-graph visual to access the full view. We'll also demonstrate in a future chapter how to provide a custom visualization loop for your viewer node, in which case leaving this button marked may be useful as well, so you can run your custom visualization when the node is executed.</p>

<p>Another benefit of limiting the size of the surface displayed in the graph is that it makes it easier to organize your graph. That is, when your viewer node can create an in-graph surface of arbitrary size, such surface could end up too large and overlap with neighboring nodes. There's no need to worry if this happens, though, because in-graph visualizations are always drawn behind everything else in the graph, in order to avoid hiding other nodes. However, this is still a undesirable situation, because the other nodes would appear in front of the in-graph visual and you'd have to move the nodes out of the way every time this overlap occurs. Even worse, if the graph is large and has many nodes, you might end up having to move other nodes as well along the graph to make extra space. This is why it is extra useful to use smaller previews for in-graph visuals, instead of full visuals.</p>


<h2 id="in-graph-only-vs-full-visual">Brief note: in-graph only vs full visual</h2>

<p>Note that a viewer node that only provides an in-graph visual is not necessarily inferior to one that also provides a full visual. As we said earlier, the full visual is just an additional resource that can be useful when you need to display visuals that are too large (or, as we'll see in other chapters, need to be customized, animated or have additional controls). If you don't need those things and the visuals you produce are not super large images, then you are probably better off just displaying the visuals in-graph.</p>

<p>For instance, if you are working with pixel art (still images), you'll probably only create tiny/small images. If you are only generating static visualizations with <a href="https://matplotlib.org">matplotlib</a> for a paper, the visuals created won't probably get so large.</p>

<p>Well, in the end, it is up to you which combination of visual features you think you'll need.</p>


<h2 id="callable-mode-and-visuals">Callable mode and visuals</h2>

<p>As you already know, when a node is in callable mode, a reference to its main callable is passed only the graph. When this is the case, Nodezator has no control over the execution of the node. Because of that Nodezator also cannot store the in-graph visual and the loop data, so the image beside the node cannot be updated, and its stored loop data cannot be updated as well. In fact, that wouldn't even make sense if you think about it. In callable mode, the node represents its behaviour, not a call with its inputs and outputs. It represents an action, that is, the action of grabing inputs and producing outputs (including the visuals). So it can in fact be executed many times along the graph, resulting in varied inputs and outputs. In other words, the action itself (the main callable being passed along) has no particular association with any visualization/outputs produced. That's why, like any other viewer node, simpler viewer nodes like the ones shown in this chapter, that is, viewer nodes that produce in-graph visual and loop data (or just in-graph visuals) have the in-graph visual taken away from them when they are in callable mode.</p>

<p>This is not a bad thing, it is just something that is worth mentioning so that you are not caught by surprise.</p>

<p>In later chapters we'll discover even more ways to provide visualizations with viewer nodes.</p>

<p><a href="ch-defining-your-first-node.htsl">Previous chapter</a> |  <a href="index.htsl">Table of contents</a> | <a href="ch-nodes-variable-parameters-custom-outputs.htsl">Next chapter</a></p>

</body>

</htsl>
